<!DOCTYPE html>
<html data-markdown-preview-plus-context="html-export">
  <head>
    <meta charset="utf-8" />
    <title>2021-12-30-Understanding-Lasso-and-Elastic-Net</title><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    jax: ["input/TeX","output/HTML-CSS"],
    extensions: ["[a11y]/accessibility-menu.js"],
    'HTML-CSS': {
      availableFonts: [],
      webFont: 'TeX',
      undefinedFamily: "serif",
      mtextFontInherit: true,
    },
    TeX: {
  "extensions": [
    "AMSmath.js",
    "AMSsymbols.js",
    "noErrors.js",
    "noUndefined.js"
  ],
  "Macros": {},
  "equationNumbers": {}
},
    showMathMenu: true
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js"></script>
    <style>.emoji {
  max-width: 1em !important;
}
del {
  text-decoration: none;
  position: relative;
}
del::after {
  border-bottom: 1px solid black;
  content: '';
  left: 0;
  position: absolute;
  right: 0;
  top: 50%;
}
ul.contains-task-list li.task-list-item {
  position: relative;
  list-style-type: none;
}
ul.contains-task-list li.task-list-item input.task-list-item-checkbox {
  position: absolute;
  transform: translateX(-100%);
  width: 30px;
}
span.critic.comment {
  position: relative;
}
span.critic.comment::before {
  content: '\1f4ac';
  position: initial;
}
span.critic.comment > span {
  display: none;
}
span.critic.comment:hover > span {
  display: initial;
  position: absolute;
  top: 100%;
  left: 0;
  border: 1px solid;
  border-radius: 5px;
  max-height: 4em;
  overflow: auto;
}
span.critic.comment:focus > span {
  display: initial;
  text-decoration: underline;
  position: initial;
  top: auto;
  left: auto;
  border: initial;
  border-radius: initial;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
  background-color: transparent;
}

body {
  overflow: initial !important;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  line-height: 1.6;
  word-wrap: break-word;
  padding: 30px;
  font-size: 16px;
  color: #333;
  background-color: #fff;
}
body > *:first-child {
  margin-top: 0 !important;
}
body > *:last-child {
  margin-bottom: 0 !important;
}
body a:not([href]) {
  color: inherit;
  text-decoration: none;
}
body .absent {
  color: #c00;
}
body .anchor {
  position: absolute;
  top: 0;
  left: 0;
  display: block;
  padding-right: 6px;
  padding-left: 30px;
  margin-left: -30px;
}
body .anchor:focus {
  outline: none;
}
body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  position: relative;
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}
body h1 .octicon-link,
body h2 .octicon-link,
body h3 .octicon-link,
body h4 .octicon-link,
body h5 .octicon-link,
body h6 .octicon-link {
  display: none;
  color: #000;
  vertical-align: middle;
}
body h1:hover .anchor,
body h2:hover .anchor,
body h3:hover .anchor,
body h4:hover .anchor,
body h5:hover .anchor,
body h6:hover .anchor {
  padding-left: 8px;
  margin-left: -30px;
  text-decoration: none;
}
body h1:hover .anchor .octicon-link,
body h2:hover .anchor .octicon-link,
body h3:hover .anchor .octicon-link,
body h4:hover .anchor .octicon-link,
body h5:hover .anchor .octicon-link,
body h6:hover .anchor .octicon-link {
  display: inline-block;
}
body h1 tt,
body h2 tt,
body h3 tt,
body h4 tt,
body h5 tt,
body h6 tt,
body h1 code,
body h2 code,
body h3 code,
body h4 code,
body h5 code,
body h6 code {
  font-size: inherit;
}
body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}
body h1 .anchor {
  line-height: 1;
}
body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}
body h2 .anchor {
  line-height: 1;
}
body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}
body h3 .anchor {
  line-height: 1.2;
}
body h4 {
  font-size: 1.25em;
}
body h4 .anchor {
  line-height: 1.2;
}
body h5 {
  font-size: 1em;
}
body h5 .anchor {
  line-height: 1.1;
}
body h6 {
  font-size: 1em;
  color: #777;
}
body h6 .anchor {
  line-height: 1.1;
}
body p,
body blockquote,
body ul,
body ol,
body dl,
body table,
body pre {
  margin-top: 0;
  margin-bottom: 16px;
}
body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}
body ul,
body ol {
  padding-left: 2em;
}
body ul.no-list,
body ol.no-list {
  padding: 0;
  list-style-type: none;
}
body ul ul,
body ul ol,
body ol ol,
body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}
body li > p {
  margin-top: 16px;
}
body dl {
  padding: 0;
}
body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}
body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}
body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}
body blockquote > :first-child {
  margin-top: 0;
}
body blockquote > :last-child {
  margin-bottom: 0;
}
body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}
body table th {
  font-weight: bold;
}
body table th,
body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}
body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}
body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}
body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}
body .emoji {
  max-width: none;
}
body span.frame {
  display: block;
  overflow: hidden;
}
body span.frame > span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid #ddd;
}
body span.frame span img {
  display: block;
  float: left;
}
body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: #333;
}
body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}
body span.align-center > span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}
body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}
body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}
body span.align-right > span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}
body span.align-right span img {
  margin: 0;
  text-align: right;
}
body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}
body span.float-left span {
  margin: 13px 0 0;
}
body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}
body span.float-right > span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}
body code,
body tt {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0, 0, 0, 0.04);
  border-radius: 3px;
}
body code:before,
body tt:before,
body code:after,
body tt:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}
body code br,
body tt br {
  display: none;
}
body del code {
  text-decoration: inherit;
}
body pre > code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
body .highlight {
  margin-bottom: 16px;
}
body .highlight pre,
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}
body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}
body pre {
  word-wrap: normal;
}
body pre code,
body pre tt {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}
body pre code:before,
body pre tt:before,
body pre code:after,
body pre tt:after {
  content: normal;
}
body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}
span.critic.comment > span {
  background-color: #fff;
}
a {
  color: #337ab7;
}

pre.editor-colors {
  background-color: #1d1f21;
  color: #c5c8c6;
}
pre.editor-colors .invisible-character {
  color: rgba(197, 200, 198, 0.2);
}
pre.editor-colors .indent-guide {
  color: rgba(197, 200, 198, 0.2);
}
pre.editor-colors .wrap-guide {
  background-color: rgba(197, 200, 198, 0.1);
}
pre.editor-colors .gutter {
  background-color: #292c2f;
}
pre.editor-colors .gutter .cursor-line {
  background-color: rgba(255, 255, 255, 0.14);
}
pre.editor-colors .line-number.cursor-line-no-selection {
  background-color: rgba(255, 255, 255, 0.14);
}
pre.editor-colors .gutter .line-number.folded,
pre.editor-colors .gutter .line-number:after,
pre.editor-colors .fold-marker:after {
  color: #fba0e3;
}
pre.editor-colors .invisible {
  color: #c5c8c6;
}
pre.editor-colors .cursor {
  border-color: white;
}
pre.editor-colors .selection .region {
  background-color: #444;
}
pre.editor-colors .bracket-matcher .region {
  border-bottom: 1px solid #f8de7e;
  margin-top: -1px;
  opacity: .7;
}
.syntax--comment {
  color: #8a8a8a;
}
.syntax--entity {
  color: #FFD2A7;
}
.syntax--entity.syntax--name.syntax--type {
  text-decoration: underline;
  color: #FFFFB6;
}
.syntax--entity.syntax--other.syntax--inherited-class {
  color: #9B5C2E;
}
.syntax--keyword {
  color: #96CBFE;
}
.syntax--keyword.syntax--control {
  color: #96CBFE;
}
.syntax--keyword.syntax--operator {
  color: #EDEDED;
}
.syntax--storage {
  color: #CFCB90;
}
.syntax--storage.syntax--modifier {
  color: #96CBFE;
}
.syntax--constant {
  color: #99CC99;
}
.syntax--constant.syntax--numeric {
  color: #FF73FD;
}
.syntax--variable {
  color: #C6C5FE;
}
.syntax--invalid.syntax--deprecated {
  text-decoration: underline;
  color: #FD5FF1;
}
.syntax--invalid.syntax--illegal {
  color: #FD5FF1;
  background-color: rgba(86, 45, 86, 0.75);
}
.syntax--string .syntax--source,
.syntax--string .syntax--meta.syntax--embedded.syntax--line {
  color: #EDEDED;
}
.syntax--string .syntax--punctuation.syntax--section.syntax--embedded {
  color: #00A0A0;
}
.syntax--string .syntax--punctuation.syntax--section.syntax--embedded .syntax--source {
  color: #00A0A0;
}
.syntax--string {
  color: #A8FF60;
}
.syntax--string .syntax--constant {
  color: #00A0A0;
}
.syntax--string.syntax--regexp {
  color: #E9C062;
}
.syntax--string.syntax--regexp .syntax--constant.syntax--character.syntax--escape,
.syntax--string.syntax--regexp .syntax--source.syntax--ruby.syntax--embedded,
.syntax--string.syntax--regexp .syntax--string.syntax--regexp.syntax--arbitrary-repetition {
  color: #FF8000;
}
.syntax--string.syntax--regexp.syntax--group {
  color: #C6A24F;
  background-color: rgba(255, 255, 255, 0.06);
}
.syntax--string.syntax--regexp.syntax--character-class {
  color: #B18A3D;
}
.syntax--string .syntax--variable {
  color: #8A9A95;
}
.syntax--support {
  color: #FFFFB6;
}
.syntax--support.syntax--function {
  color: #DAD085;
}
.syntax--support.syntax--constant {
  color: #FFD2A7;
}
.syntax--support.syntax--type.syntax--property-name.syntax--css {
  color: #EDEDED;
}
.syntax--source .syntax--entity.syntax--name.syntax--tag,
.syntax--source .syntax--punctuation.syntax--tag {
  color: #96CBFE;
}
.syntax--source .syntax--entity.syntax--other.syntax--attribute-name {
  color: #FF73FD;
}
.syntax--entity.syntax--other.syntax--attribute-name {
  color: #FF73FD;
}
.syntax--entity.syntax--name.syntax--tag.syntax--namespace,
.syntax--entity.syntax--other.syntax--attribute-name.syntax--namespace {
  color: #E18964;
}
.syntax--meta.syntax--preprocessor.syntax--c {
  color: #8996A8;
}
.syntax--meta.syntax--preprocessor.syntax--c .syntax--keyword {
  color: #AFC4DB;
}
.syntax--meta.syntax--cast {
  color: #676767;
}
.syntax--meta.syntax--sgml.syntax--html .syntax--meta.syntax--doctype,
.syntax--meta.syntax--sgml.syntax--html .syntax--meta.syntax--doctype .syntax--entity,
.syntax--meta.syntax--sgml.syntax--html .syntax--meta.syntax--doctype .syntax--string,
.syntax--meta.syntax--xml-processing,
.syntax--meta.syntax--xml-processing .syntax--entity,
.syntax--meta.syntax--xml-processing .syntax--string {
  color: #8a8a8a;
}
.syntax--meta.syntax--tag .syntax--entity,
.syntax--meta.syntax--tag > .syntax--punctuation,
.syntax--meta.syntax--tag.syntax--inline .syntax--entity {
  color: #FF73FD;
}
.syntax--meta.syntax--tag .syntax--name,
.syntax--meta.syntax--tag.syntax--inline .syntax--name,
.syntax--meta.syntax--tag > .syntax--punctuation {
  color: #96CBFE;
}
.syntax--meta.syntax--selector.syntax--css .syntax--entity.syntax--name.syntax--tag {
  text-decoration: underline;
  color: #96CBFE;
}
.syntax--meta.syntax--selector.syntax--css .syntax--entity.syntax--other.syntax--attribute-name.syntax--tag.syntax--pseudo-class {
  color: #8F9D6A;
}
.syntax--meta.syntax--selector.syntax--css .syntax--entity.syntax--other.syntax--attribute-name.syntax--id {
  color: #8B98AB;
}
.syntax--meta.syntax--selector.syntax--css .syntax--entity.syntax--other.syntax--attribute-name.syntax--class {
  color: #62B1FE;
}
.syntax--meta.syntax--property-group .syntax--support.syntax--constant.syntax--property-value.syntax--css,
.syntax--meta.syntax--property-value .syntax--support.syntax--constant.syntax--property-value.syntax--css {
  color: #F9EE98;
}
.syntax--meta.syntax--preprocessor.syntax--at-rule .syntax--keyword.syntax--control.syntax--at-rule {
  color: #8693A5;
}
.syntax--meta.syntax--property-value .syntax--support.syntax--constant.syntax--named-color.syntax--css,
.syntax--meta.syntax--property-value .syntax--constant {
  color: #87C38A;
}
.syntax--meta.syntax--constructor.syntax--argument.syntax--css {
  color: #8F9D6A;
}
.syntax--meta.syntax--diff,
.syntax--meta.syntax--diff.syntax--header {
  color: #F8F8F8;
  background-color: #0E2231;
}
.syntax--meta.syntax--separator {
  color: #60A633;
  background-color: #242424;
}
.syntax--meta.syntax--line.syntax--entry.syntax--logfile,
.syntax--meta.syntax--line.syntax--exit.syntax--logfile {
  background-color: rgba(238, 238, 238, 0.16);
}
.syntax--meta.syntax--line.syntax--error.syntax--logfile {
  background-color: #751012;
}
.syntax--source.syntax--gfm {
  color: #999;
}
.syntax--gfm .syntax--markup.syntax--heading {
  color: #eee;
}
.syntax--gfm .syntax--link {
  color: #555;
}
.syntax--gfm .syntax--variable.syntax--list,
.syntax--gfm .syntax--support.syntax--quote {
  color: #555;
}
.syntax--gfm .syntax--link .syntax--entity {
  color: #ddd;
}
.syntax--gfm .syntax--raw {
  color: #aaa;
}
.syntax--markdown .syntax--paragraph {
  color: #999;
}
.syntax--markdown .syntax--heading {
  color: #eee;
}
.syntax--markdown .syntax--raw {
  color: #aaa;
}
.syntax--markdown .syntax--link {
  color: #555;
}
.syntax--markdown .syntax--link .syntax--string {
  color: #555;
}
.syntax--markdown .syntax--link .syntax--string.syntax--title {
  color: #ddd;
}
/*
   This defines styling rules for syntax classes.

   See the naming conventions for a list of syntax classes:
   https://flight-manual.atom.io/hacking-atom/sections/syntax-naming-conventions

   When styling rules conflict:
   - The last rule overrides previous rules.
   - The rule with most classes and pseudo-classes overrides the last rule.
*/
.syntax--keyword {
  color: #96CBFE;
}
.syntax--keyword.syntax--storage {
  color: #96CBFE;
}
.syntax--keyword.syntax--type {
  color: #FFFFB6;
}
.syntax--keyword.syntax--operator {
  color: #96CBFE;
}
.syntax--keyword.syntax--function {
  color: #C6C5FE;
}
.syntax--keyword.syntax--variable {
  color: #C6C5FE;
}
.syntax--keyword.syntax--symbolic {
  color: #EDEDED;
}
.syntax--entity {
  color: #C5C8C6;
}
.syntax--entity.syntax--variable {
  color: #C5C8C6;
}
.syntax--entity.syntax--support {
  color: #C6C5FE;
}
.syntax--entity.syntax--decorator:last-child {
  color: #FFD2A7;
}
.syntax--entity.syntax--label {
  text-decoration: underline;
}
.syntax--entity.syntax--package {
  color: #FFD2A7;
}
.syntax--entity.syntax--function {
  color: #FFD2A7;
}
.syntax--entity.syntax--operator {
  color: #FFD2A7;
}
.syntax--entity.syntax--operator.syntax--symbolic {
  color: #EDEDED;
}
.syntax--entity.syntax--type {
  color: #FFFFB6;
}
.syntax--entity.syntax--tag {
  color: #96CBFE;
}
.syntax--entity.syntax--attribute {
  color: #FF73FD;
}
.syntax--punctuation {
  color: #C5C8C6;
}
.syntax--punctuation.syntax--accessor.syntax--member {
  color: #EDEDED;
}
.syntax--string {
  color: #A8FF60;
}
.syntax--string.syntax--immutable {
  color: #A8FF60;
}
.syntax--string.syntax--part {
  color: #00A0A0;
}
.syntax--string.syntax--regexp {
  color: #A8FF60;
}
.syntax--string.syntax--regexp.syntax--group {
  color: #A8FF60;
  background-color: #1d1f21;
}
.syntax--string.syntax--regexp .syntax--constant.syntax--character.syntax--escape {
  color: #A8FF60;
}
.syntax--string.syntax--regexp .syntax--constant.syntax--character.syntax--escape.syntax--code {
  color: #00A0A0;
}
.syntax--string.syntax--regexp.syntax--language {
  color: #96CBFE;
}
.syntax--string.syntax--regexp.syntax--variable {
  color: #C5C8C6;
}
.syntax--string.syntax--regexp.syntax--punctuation {
  color: #E9C062;
}
.syntax--constant {
  color: #FF73FD;
}
.syntax--constant.syntax--numeric {
  color: #FF73FD;
}
.syntax--constant.syntax--character {
  color: #A8FF60;
}
.syntax--constant.syntax--character.syntax--escape {
  color: #A8FF60;
}
.syntax--constant.syntax--character.syntax--code {
  color: #00A0A0;
}
.syntax--text {
  color: #C5C8C6;
}
.syntax--markup.syntax--heading {
  color: #eee;
}
.syntax--markup.syntax--list {
  color: #555;
}
.syntax--markup.syntax--quote {
  color: #555;
}
.syntax--markup.syntax--raw {
  color: #aaa;
}
.syntax--markup.syntax--link {
  color: #555;
}
.syntax--markup.syntax--alt {
  color: #ddd;
}
.syntax--comment {
  color: #8A8A8A;
}
.syntax--comment.syntax--caption {
  color: #999999;
  font-weight: bold;
}
.syntax--comment.syntax--term {
  color: #a1a1a1;
}
.syntax--comment.syntax--punctuation {
  color: #8A8A8A;
  font-weight: normal;
}
.syntax--invalid:not(.syntax--punctuation).syntax--illegal {
  color: #FD5FF1 !important;
  background-color: rgba(86, 45, 86, 0.75) !important;
}
.syntax--invalid:not(.syntax--punctuation).syntax--deprecated {
  color: #FD5FF1 !important;
  text-decoration: underline !important;
}
.syntax--source.syntax--css .syntax--entity.syntax--function {
  color: #C5C8C6;
}
.syntax--source.syntax--css .syntax--entity.syntax--function.syntax--support {
  color: #DAD085;
}
.syntax--source.syntax--css .syntax--entity.syntax--selector {
  color: #FF73FD;
}
.syntax--source.syntax--css .syntax--entity.syntax--selector.syntax--tag {
  color: #96CBFE;
  text-decoration: underline;
}
.syntax--source.syntax--css .syntax--entity.syntax--selector.syntax--id {
  color: #8B98AB;
}
.syntax--source.syntax--css .syntax--entity.syntax--selector.syntax--class {
  color: #62B1FE;
}
.syntax--source.syntax--css .syntax--entity.syntax--property.syntax--support {
  color: #EDEDED;
}
.syntax--source.syntax--css .syntax--entity.syntax--variable {
  color: #C6C5FE;
}
.syntax--source.syntax--css .syntax--entity.syntax--keyframe {
  color: #C6C5FE;
}
.syntax--source.syntax--css .syntax--constant {
  color: #C5C8C6;
}
.syntax--source.syntax--css .syntax--constant.syntax--support {
  color: #F9EE98;
}
.syntax--source.syntax--css .syntax--constant.syntax--numeric {
  color: #99CC99;
}
.syntax--source.syntax--css .syntax--constant.syntax--numeric.syntax--unit {
  color: #99CC99;
}
.syntax--source.syntax--css .syntax--constant.syntax--media {
  color: #FFD2A7;
}
.syntax--source.syntax--css .syntax--constant.syntax--color {
  color: #99CC99;
}
.syntax--source.syntax--css .syntax--constant.syntax--offset {
  color: #FFD2A7;
}
.syntax--source.syntax--css .syntax--constant.syntax--offset.syntax--unit {
  color: #FFD2A7;
}
.syntax--source.syntax--css .syntax--punctuation {
  color: #C5C8C6;
}
.syntax--source.syntax--css .syntax--punctuation.syntax--wildcard {
  color: #96CBFE;
  text-decoration: underline;
}
.syntax--source.syntax--html .syntax--punctuation.syntax--tag {
  color: #96CBFE;
}
.syntax--source.syntax--html .syntax--meta.syntax--doctype {
  color: #8A8A8A;
}

/*
 * Your Stylesheet
 *
 * This stylesheet is loaded when Atom starts up and is reloaded automatically
 * when it is changed and saved.
 *
 * Add your own CSS or Less to fully customize Atom.
 * If you are unfamiliar with Less, you can read more about it here:
 * http://lesscss.org
 */
/*
 * Examples
 * (To see them, uncomment and save)
 */
</style>

  </head>
  <body>
    <h1>Understanding Lasso and Elastic Net</h1>
<p>Algorithms such as Lasso and Elastic Net enjoy increasing popularity and have long found their way into the toolboxes of economists. Naturally, all standard programming languages feature packages that allow for off the shelf implementation and basic machine learning textbooks offer rich explanations of the theoretical foundations. In contrast, details about the efficient numerical solution algorithms and their implementation are rarely provided. If you - like me - would also like to gain a deeper understanding of the algorithms that are employed to solve for the solution paths of e.g. Lasso and Elastic Net, this tutorial might be interesting to you. It aims at implementing the pathwise coordinate descent algorithm following Friedman et al. (2007). In addition, this tutorial is written in julia, given julia’s increasing popularity especially in macroeconomics.</p>
<p>You can also find a jupyter notebook version with interactive charts in the respective repository on my GitHub. As a small disclaimer, I try to write codes for these tutorials that are relatively intuitive and easy to read and understand. I am not a computer scientist and thus there are naturally always things to improve in terms of speed as well as style. In addition, the codes developed in this tutorial might of course contain bugs. As such, these codes are intended to improve the understanding of the theoretical foundations and inner workings of popular librares and packages and are not recommended to be used in actual application. Nonetheless, I hope that this tutorial is useful for some.</p>
<h2>1 Some Derivations</h2>
<p>As will become clear in a second, the algorithm rests on three key features:</p>
<ul>
<li>Iterating over the regression coefficients and updating them one at a time conditional on all others</li>
<li>Partialing out the other coefficients at each step to convert the problem into a univariate one for which solutions are easy to compute</li>
<li>Normalizing the predictors to be orthonormal</li>
</ul>
<h3>1.1 Lasso</h3>
<p>Before we start with the actual code, let’s derive the algorithm following Friedman et al. (2007) to build some intuition.</p>
<p>Let <span class="math inline-math"><script type="math/tex">N</script></span> denote the number of observations and <span class="math inline-math"><script type="math/tex">K</script></span> denote the number of variables. The Lasso optimization problem is given by:</p>
<span class="math display-math"><script type="math/tex; mode=display">\text{min}_{\beta_j} \:\:f(\hat{\beta}) = \frac{1}{2} \sum_{i=1}^{N} (y_i - \sum_{k=j}^{K} x_{i,k}\beta_k)^2 %2B \lambda \sum_{k=j}^{K}|\beta_k|
</script></span>
<p>Similarly, the problem can be rewritten as:</p>
<span class="math display-math"><script type="math/tex; mode=display">\text{min}_{\beta_j} \:\: f(\hat{\beta}) = \frac{1}{2} \sum_{i=1}^{N} (y_i - \sum_{k\neq j}^{K} x_{i,k}\beta_k - x_{i,j} \beta_j)^2 %2B \lambda \sum_{k=j}^{K}|\beta_k| %2B \lambda|\beta_j|
</script></span>
<p>For a single <span class="math inline-math"><script type="math/tex">\beta_j</script></span> (conditional on all others), the solution to the Lasso problem is:</p>
<span class="math display-math"><script type="math/tex; mode=display">\frac{\partial f(\hat{\beta}) }{\partial \beta_j} =  -\sum_{i=1}^{N} (y_i - \sum_{k\neq j}^{K} x_{i,k}\beta_k - x_{i,j} \beta_j)x_{i,j} \pm \lambda = 0
</script></span>
<p>With <span class="math inline-math"><script type="math/tex">\tilde{y_i}^{(j)} = \sum_{k\neq j}^{K} x_{i,k}\beta_k</script></span>, this yields:</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}^{(j)} - x_{i,j} \beta_j)x_{i,j} \mp \lambda =0
</script></span>
<p>If 𝑋:,𝑗 is normalized, such that it is orthonormal, then this can be rewritten as:</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}^{(j)})x_{i,j} -  \beta_j \mp \lambda =0
</script></span>
<p>and hence</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_j -  \beta_j \mp \lambda =0
</script></span>
<p>which gives</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,Lasso} = \hat{\beta}_j \mp \lambda
</script></span>
<p>Following Donoho and Johnstone (1995) and Friedman et al. (2007), this is equivalent to the soft-thresholding rule:</p>
<span class="math display-math"><script type="math/tex; mode=display">\begin{align}
\hat{\beta}_{j,Lasso} =
\begin{cases}
\hat{\beta}_j - \lambda, &\text{   if $\hat{\beta}_j>0$ and $\lambda < |\hat{\beta}_j|$,}\\
\hat{\beta}_j  + \lambda, &\text{   if $\hat{\beta}_j<0$ and $\lambda < |\hat{\beta}_j|$,}\\
0,                     &\text{    $\lambda > |\hat{\beta}_j|$.}
\end{cases}
\end{align}
</script></span>
<p>Equivalently, the soft-thresholding rule can be expressed as</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,Lasso} = S(\hat{\beta}_j,\lambda) = \text{sign}(\hat{\beta}_j)(|\hat{\beta}_j|-\lambda)_+
</script></span>
<p>Alternatively, we can again start from</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}^{(j)})x_{i,j} -  \beta_j \mp \lambda =0,
</script></span>
<p>insert</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}^{(j)}+\beta_j x_{i,j}-\beta_j x_{i,j})x_{i,j} -  \beta_j \mp \lambda =0,
</script></span>
<p>which simplifies to</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}+\beta_j x_{i,j})x_{i,j} -  \beta_j \mp \lambda =0,
</script></span>
<p>where <span class="math inline-math"><script type="math/tex">\tilde{y_i} =  \sum_{k= 1}^{K} x_{i,k}\beta_k</script></span>. This then yields</p>
<span class="math display-math"><script type="math/tex; mode=display"> \hat{\beta}_{j,Lasso} = \hat{\beta}_{j,Lasso} + (y_i-\tilde{y_i})x_{i,j} \mp \lambda
</script></span>
<p>This simplifies to the alternative soft-thresholding rule</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,Lasso} = S(\hat{\beta}_{j,Lasso} + (y_i-\tilde{y_i})x_{i,j},\lambda)
</script></span>
<p>The Lasso solution for a given <span class="math inline-math"><script type="math/tex">\lambda</script></span> can then be computed by iterating on either soft-thresholding rule for each coefficient, <span class="math inline-math"><script type="math/tex">j</script></span>, until convergence, i.e.:</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,Lasso}^{(p)} = S\left((y_i-\tilde{y_i}^{(j)})x_{i,j},\lambda\right)\:\:\:\: \text{$p=1$,$\dots$, until convergence}
</script></span>
<p>or</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,Lasso}^{(p)} = S\left(\hat{\beta}_{j,Lasso}^{(p-1)} + (y_i-\tilde{y_i})x_{i,j},\lambda\right) \:\:\:\: \text{$p=1$,$\dots$, until convergence}
</script></span>
<h3>1.2 Elastic Net</h3>
<p>The derivation for Elastic Net is generally similar. The optimization problem is given by:</p>
<span class="math display-math"><script type="math/tex; mode=display">\text{min}_{\beta_j} \:\:f(\hat{\beta}) = \frac{1}{2} \sum_{i=1}^{N} (y_i - \sum_{k=j}^{K} x_{i,k}\beta_k)^2 + \lambda_1 \sum_{k=j}^{K}|\beta_k| +\lambda_2 \frac{1}{2}\sum_{k=j}^{K}\beta_k^2
</script></span>
<p>For ease of implementation, an equivalent formulation reads:</p>
<span class="math display-math"><script type="math/tex; mode=display">\text{min}_{\beta_j} \:\:f(\hat{\beta}) = \frac{1}{2} \sum_{i=1}^{N} (y_i - \sum_{k=j}^{K} x_{i,k}\beta_k)^2 + \alpha \lambda \sum_{k=j}^{K}|\beta_k| +(1-\alpha)\lambda \frac{1}{2}\sum_{k=j}^{K}\beta_k^2
</script></span>
<p>where <span class="math inline-math"><script type="math/tex">\alpha = \frac{\lambda_1}{\lambda_1+\lambda_2}</script></span> and <span class="math inline-math"><script type="math/tex">\lambda = \lambda_1+\lambda_2</script></span>. Following the same steps as above, this leads to</p>
<span class="math display-math"><script type="math/tex; mode=display">\sum_{i=1}^{N} (y_i-\tilde{y_i}^{(j)})x_{i,j} -  \beta_j \mp \alpha\lambda - (1-\alpha)\lambda \beta_j=0,
</script></span>
<p>and hence the updating equation:</p>
<span class="math display-math"><script type="math/tex; mode=display">\hat{\beta}_{j,EL}^{(p)} = \frac{S\left((y_i-\tilde{y_i}^{(j)})x_{i,j},\alpha\lambda\right)}{1+(1-\alpha)\lambda}
</script></span>
<p>This is just a rescaled version of the Lasso estimator derived above. This allows for a convenient and parsimonious implementation of the algorithm, where the Lasso estimator is computed as a special case of the Elastic Net estimator. The below code makes convenient use of this feature.</p>
<h2>2 The Pathwise Coordinate Descent Algorithm</h2>
<p>First, we need to load a couple of packages:</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> Load  the required packages</span>
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> DataFrames
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> CSV
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> LinearAlgebra
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> Plots
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> Statistics
<span class="syntax--keyword syntax--control syntax--using syntax--julia">using</span> StatsBase</span></pre>
<p>Below, I construct a Elastic Net (EL) estimator structure. This structure contains the basic parameters that define the optimization problem, such as the outcome variables, the predictors, the number of predictors, the number of observations, and the maximum number of iterations etc.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">abstract type</span> EL_estimator <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

<span class="syntax--keyword syntax--other syntax--julia">mutable struct</span> EL_CD<span class="syntax--meta syntax--bracket syntax--julia">{</span>T<span class="syntax--meta syntax--bracket syntax--julia">}</span> <span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">&lt;:</span> <span class="syntax--support syntax--type syntax--julia">EL_estimator</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize data types</span>
    Y<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span>
    X<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span>
    n<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">T</span>
    p<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">T</span>
    maxIter<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Int</span>
    tol<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span>
    points<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">T</span>

    <span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">EL_CD</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>Y<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> X<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>points<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">T</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>maxIter<span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span><span class="syntax--constant syntax--numeric syntax--julia">100</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>tol<span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span><span class="syntax--constant syntax--numeric syntax--julia">1e-5</span><span class="syntax--meta syntax--bracket syntax--julia">)</span> <span class="syntax--keyword syntax--other syntax--julia">where</span> T

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the size of the data</span>
        n<span class="syntax--meta syntax--bracket syntax--julia">,</span> p <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">size</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>X<span class="syntax--meta syntax--bracket syntax--julia">)</span>

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> fill structure</span>
        <span class="syntax--support syntax--function syntax--julia">new</span><span class="syntax--support syntax--type syntax--julia">{T}</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>Y<span class="syntax--meta syntax--bracket syntax--julia">,</span> X<span class="syntax--meta syntax--bracket syntax--julia">,</span> n<span class="syntax--meta syntax--bracket syntax--julia">,</span> p<span class="syntax--meta syntax--bracket syntax--julia">,</span> maxIter<span class="syntax--meta syntax--bracket syntax--julia">,</span> tol<span class="syntax--meta syntax--bracket syntax--julia">,</span> points<span class="syntax--meta syntax--bracket syntax--julia">)</span>
    <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>We will now build a couple of functions that operate on our newly created <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">EL_CD</code> structure and do the heavy lifting when computing the EL paths. Generally, it is advisable to split up the code into functions to avoid ambiguity for the compiler which in turn leads to gains in speed.</p>
<p>To make our estimator yet a little faster, we can rely on a clever strategy called <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">warm-start</code>. This means, that we use the solution path at the previous grid point as the initial value for the next grid point. The idea is that the solutions should not change too much from one grid point to the next, such that the algorithm then already starts close to the solution. This then reduces the number of iterations required until convergence and hence computational time.</p>
<p>Naturally, the question now is at which grid point to start. As a natural starting point, it makes sense to select the <span class="math inline-math"><script type="math/tex">\lambda</script></span> for which all coefficients are <span class="math inline-math"><script type="math/tex">0</script></span> and to reduce the <span class="math inline-math"><script type="math/tex">\lambda</script></span> in consecutive steps until the OLS solution is reached. This specific <span class="math inline-math"><script type="math/tex">\lambda</script></span> value of course depends on the optimization problem at hand. Let’s thus start with writing a function that computes this <span class="math inline-math"><script type="math/tex">\lambda</script></span> value dynamically.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">findlmax</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>x<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>y<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> find the lambda where all parameters = 0</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> <span class="syntax--support syntax--function syntax--julia">findmax</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--support syntax--function syntax--julia">abs</span>.<span class="syntax--meta syntax--bracket syntax--julia">(</span>X<span class="syntax--keyword syntax--operator syntax--transposed-variable syntax--julia">'</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>Y<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span>
<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>In addtion, the grid points for <span class="math inline-math"><script type="math/tex">\lambda</script></span> are usually geometrically spaced. The grid itself, however, is still defined by its start and end points, as well as the total number of grid points. Only the spacing between the points is not homogenous. We thus also need a function that takes these three input arguments and returns a corresponding sqeuence of geometrically spaced values.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">geomprog</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>a<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>b<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">,</span>points<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Int</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute rate of geometric progression</span>
    r <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--meta syntax--bracket syntax--julia">(</span>b<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">/</span>a<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">^</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">/</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>points<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> return sequence of geometrically spaced values</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> a<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>r<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">.^</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">0</span><span class="syntax--keyword syntax--operator syntax--range syntax--julia">:</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--range syntax--julia">:</span>points<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">;</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span>
<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>To complete the automatic computation of our grid, we now simply need to put the two functions together. <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">endo_grid</code> simply calls the <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">geomprog</code> function with the <span class="math inline-math"><script type="math/tex">\lambda</script></span> that sets all coefficients to zero. The function then returns a grid or sequence of the desired number of <span class="math inline-math"><script type="math/tex">\lambda</script></span>-values that is taylored to the specific problem at hand. This function will be called as soon as the <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">EL_CD</code> structure is initialized.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">endo_grid</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>x<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> y<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> points<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Int</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the endogenous grid starting from the Lasso parameter that sets all βicients = 0.</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> <span class="syntax--support syntax--function syntax--julia">geomprog</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--support syntax--function syntax--julia">findlmax</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>x<span class="syntax--meta syntax--bracket syntax--julia">,</span>y<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> <span class="syntax--constant syntax--numeric syntax--julia">0.1</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> points<span class="syntax--meta syntax--bracket syntax--julia">)</span>

<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>A core ingredient of the pathwise coordinate descent algorithm is the <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">soft-thresholding</code> rule that computes the parameter updates. The below function implements the rule according to the algebra derived above.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">soft_thresholding</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>beta<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> lambda<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    t <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">append!</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">0.0</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span><span class="syntax--meta syntax--bracket syntax--julia">,</span><span class="syntax--support syntax--function syntax--julia">abs</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>beta<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span>lambda<span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the soft-thresholding rule</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> <span class="syntax--support syntax--function syntax--julia">sign</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>beta<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span><span class="syntax--support syntax--function syntax--julia">findmax</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>t<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span>
<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>We now have functions that compute the gird for <span class="math inline-math"><script type="math/tex">\lambda</script></span> as well as the soft-thresholding rule in place. Let’s thus finally start to code up the coordinate descent algorihtm. Before we dive into it, however, it makes sense to recall that the final algorithm is essentially composed of two loops. The inner loop iterates over the coefficients to compute the solution at a given <span class="math inline-math"><script type="math/tex">\lambda</script></span>. The outer loop iterates over the grid for <span class="math inline-math"><script type="math/tex">\lambda</script></span>. For readability and convenience, it again makes sense to split up the code into functions accordingly. First, we will thus write a function that computes the inner loop.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia">
<span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">coordinate_descent_EL</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>init<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Array{Float64,2}</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> lambda<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> model<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">EL_CD</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> alpha<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize an array containing the normed predictors</span>
    X_n <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">similar</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>X<span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> orthonormalize each predictor variable</span>
    <span class="syntax--keyword syntax--control syntax--julia">for</span> i <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--range syntax--julia">:</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>p
        X_n<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>:<span class="syntax--meta syntax--bracket syntax--julia">,</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span> <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>X<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>:<span class="syntax--meta syntax--bracket syntax--julia">,</span>i<span class="syntax--meta syntax--bracket syntax--julia">]<span class="syntax--keyword syntax--operator syntax--transpose syntax--julia">.</span></span></span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">/</span><span class="syntax--support syntax--function syntax--julia">norm</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>X<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>:<span class="syntax--meta syntax--bracket syntax--julia">,</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span><span class="syntax--meta syntax--bracket syntax--julia">)</span>
    <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> set the initial number of iterations to 1</span>
    iter_ <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">1</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize coefficients</span>
    coeff <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> init

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize the supremum of the Elastic Net/Lasso estimates</span>
    sup <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">10000000.0</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize the difference of the coefficient estimates between iterations</span>
    diffs <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">zeros</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>p<span class="syntax--meta syntax--bracket syntax--julia">,</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> run the updating algorithm until either the maximum number of iterations is reached or the supremum</span>
    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> of the coefficient estimates is smaller than the set tolerance.</span>
    <span class="syntax--keyword syntax--control syntax--julia">while</span> iter_ <span class="syntax--keyword syntax--operator syntax--relation syntax--julia">&lt;</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>maxIter <span class="syntax--keyword syntax--operator syntax--boolean syntax--julia">&amp;&amp;</span> sup <span class="syntax--keyword syntax--operator syntax--relation syntax--julia">&gt;</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>tol

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> iterate over the coefficients/predictors</span>
        <span class="syntax--keyword syntax--control syntax--julia">for</span> i <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--range syntax--julia">:</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>p

            <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the predictions</span>
            Y_tilde <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> X_n<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>coeff

            <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the residual</span>
            eps <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>Y <span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span> Y_tilde

            <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the Lasso/Elastic Net estimates</span>
            beta_EL <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">soft_thresholding</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>coeff<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>i<span class="syntax--meta syntax--bracket syntax--julia">]<span class="syntax--keyword syntax--operator syntax--transpose syntax--julia">.</span></span></span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">+</span>X_n<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>:<span class="syntax--meta syntax--bracket syntax--julia">,</span>i<span class="syntax--meta syntax--bracket syntax--julia">]'</span></span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>eps<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span><span class="syntax--meta syntax--bracket syntax--julia">,</span> alpha<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>lambda<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">/</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">+</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span>alpha<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">*</span>lambda<span class="syntax--meta syntax--bracket syntax--julia">)</span>

            <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the difference in coefficient estimates between iterations</span>
            diffs<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span> <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> beta_EL<span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">-</span>coeff<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span>

            <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> update the coefficient with the EL/Lasso estimate</span>
            coeff<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span> <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> beta_EL

        <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> update the number of iterations</span>
        iter_ <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> iter_ <span class="syntax--keyword syntax--operator syntax--arithmetic syntax--julia">+</span> <span class="syntax--constant syntax--numeric syntax--julia">1</span>

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> update the supremum of the difference in coefficient estimates</span>
        sup <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">findmax</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--support syntax--function syntax--julia">abs</span>.<span class="syntax--meta syntax--bracket syntax--julia">(</span>diffs<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span>

    <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> return the coefficients, supremum, and number of iterations</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> coeff<span class="syntax--meta syntax--bracket syntax--julia">,</span> sup<span class="syntax--meta syntax--bracket syntax--julia">,</span> iter_

<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>The function works as follows. First, each predictor is normalized (for transparancy, this step is done within the function, but could of course be pre-computed). Then, the initial number of iterations is set to <span class="math inline-math"><script type="math/tex">1</script></span>. In addition, the difference of the coefficient estimates between iterations is initialized and its supremum set to a high initial value. For each iteration of the while loop, the function now computes the regression residuals and iteratively updates the parameter estimates according to the derived soft-thresholding rule. This process is repeated until convergence, i.e. until either the maximum number of iterations is achieved or until the supremum of the difference of the coefficient estiamtes between iterations is smaller than the specified tolerance. Finally, the function returns the coefficient estimates, the supremum, and the number of iterations. This yields the solution for a given <span class="math inline-math"><script type="math/tex">\lambda</script></span> and <span class="math inline-math"><script type="math/tex">\alpha</script></span>.</p>
<p>Now, we turn to the the function for the outer loop, that computes the entire solution path across grid points.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--keyword syntax--other syntax--julia">function</span> <span class="syntax--entity syntax--name syntax--function syntax--julia">compute_path</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">EL_CD</span><span class="syntax--meta syntax--bracket syntax--julia">,</span> Type<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">String</span><span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span><span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>Lasso<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span><span class="syntax--meta syntax--bracket syntax--julia">,</span> alpha<span class="syntax--keyword syntax--operator syntax--relation syntax--types syntax--julia">::</span><span class="syntax--support syntax--type syntax--julia">Float64</span><span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span><span class="syntax--constant syntax--numeric syntax--julia">1.0</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize the coefficients at 0, because the first grid point sets all coefficients</span>
    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> exactly to 0 by construction</span>
    init <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">zeros</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>p<span class="syntax--meta syntax--bracket syntax--julia">,</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initialize the array containing the solution path</span>
    coeffs <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">zeros</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>p<span class="syntax--meta syntax--bracket syntax--julia">,</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>points<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> if the Lasso solution is to be computed, set the lambda ratio of Elastic net to 1.</span>
    <span class="syntax--keyword syntax--control syntax--julia">if</span> Type <span class="syntax--keyword syntax--operator syntax--relation syntax--julia">==</span> <span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>Lasso<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span>
        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> Set alpha  to 1.0, if Type is Lasso</span>
        alpha <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">1.0</span>
    <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the endogenous grid</span>
    endogrid <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">endo_grid</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>X<span class="syntax--meta syntax--bracket syntax--julia">,</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>Y<span class="syntax--meta syntax--bracket syntax--julia">,</span> model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>points<span class="syntax--meta syntax--bracket syntax--julia">)</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> Compute the Elastic Net/Lasso solution for every gripd point</span>
    <span class="syntax--keyword syntax--control syntax--julia">for</span> i <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--keyword syntax--operator syntax--range syntax--julia">:</span>model<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span>points

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the solution for grid point i</span>
        c <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">coordinate_descent_EL</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>init<span class="syntax--meta syntax--bracket syntax--julia">,</span> endogrid<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span><span class="syntax--meta syntax--bracket syntax--julia">,</span> model<span class="syntax--meta syntax--bracket syntax--julia">,</span> alpha<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span><span class="syntax--constant syntax--numeric syntax--julia">1</span><span class="syntax--meta syntax--bracket syntax--julia">]</span></span>

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> use warm-start to speed up convergence</span>
        init <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> c

        <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> save the solution</span>
        coeffs<span class="syntax--meta syntax--array syntax--julia"><span class="syntax--meta syntax--bracket syntax--julia">[</span>:<span class="syntax--meta syntax--bracket syntax--julia">,</span>i<span class="syntax--meta syntax--bracket syntax--julia">]</span></span> <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> c
    <span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span>

    <span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> return the solution path</span>
    <span class="syntax--keyword syntax--control syntax--julia">return</span> coeffs
<span class="syntax--keyword syntax--control syntax--end syntax--julia">end</span></span></pre>
<p>First, a few objects are initialized. Given that we start at the <span class="math inline-math"><script type="math/tex">\lambda</script></span> for which all parameters are zero, it makes sense to set the initial values for the first grid point to zero as well. Next, if Lasso is supposed to be estimated, <span class="math inline-math"><script type="math/tex">\alpha</script></span> is set to <span class="math inline-math"><script type="math/tex">1</script></span>. The EL soft-thresholding rule collapses to the one of Lasso in this case. As a next step, the function computes the grid of <span class="math inline-math"><script type="math/tex">\lambda</script></span> values, based on the functions that we set up above. Now comes the actual outer loop. For each of the previously computed grid points, the loop iterates over the grid points and calls the  <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">coordinate_descent_EL</code> function, i.e. the function that contains the inner loop which yields the EL solution for a given <span class="math inline-math"><script type="math/tex">\lambda</script></span> and <span class="math inline-math"><script type="math/tex">\alpha</script></span>. In addition, the initial value is then updated to the EL solution of the current grid point, which thus serves as a starting value for the next grid point. This is the <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;"> warm-start</code> strategy outlined at above.</p>
<p>This is all we need!</p>
<h2>3 The Objective function</h2>
<p>Before we jump into an example, it is illustrative to have a look at the behaviour of the EL penalty function for a few theoretical examples. The codes for a variant of these charts with sliders can be found in the GitHub repository.</p>
<p>@import “C:\Users\A2010183\Desktop\Projects\<a href="http://MaximilianSchroeder.github.io">MaximilianSchroeder.github.io</a>\assets\images\Lasso1.JPG”</p>
<p>The above plot shows the shape of the penalty function (LHS) as well as objective function (RHS) for <span class="math inline-math"><script type="math/tex">\hat{\beta}=1.1</script></span>, <span class="math inline-math"><script type="math/tex">\lambda=0.7</script></span>, and <span class="math inline-math"><script type="math/tex">\alpha=1.0</script></span>. As we can see - for this parameterization - the EL penalty function is identical to the one of Lasso, because <span class="math inline-math"><script type="math/tex">\alpha=1.0</script></span>. In addition, given that <span class="math inline-math"><script type="math/tex">\lambda<\hat{\beta}</script></span>, we can directly see from the soft-thresholding rule derived above that <span class="math inline-math"><script type="math/tex">\beta_{Lasso}=0.4</script></span>, which is also the result that we see in the plot on the RHS.</p>
<p>In contrast, if we set <span class="math inline-math"><script type="math/tex">\lambda=2.0</script></span>, we have <span class="math inline-math"><script type="math/tex">\lambda>\hat{\beta}</script></span> and thus the Lasso solution is <span class="math inline-math"><script type="math/tex">0</script></span>, which can again also be seen directly from the soft-thresholding rule.</p>
<p>@import “C:\Users\A2010183\Desktop\Projects\<a href="http://MaximilianSchroeder.github.io">MaximilianSchroeder.github.io</a>\assets\images\Lasso2.JPG”</p>
<p>Finally, if we set <span class="math inline-math"><script type="math/tex">\alpha=0.5</script></span>, the penalty function of EL is between the one of Ridge regression and Lasso. In addition, even though <span class="math inline-math"><script type="math/tex">\lambda>\hat{\beta}</script></span>, the solution for the EL estimate is now slightly positive. This result can again be directly derived from the soft-thresholding rule for EL.</p>
<p>@import “C:\Users\A2010183\Desktop\Projects\<a href="http://MaximilianSchroeder.github.io">MaximilianSchroeder.github.io</a>\assets\images\Lasso3.JPG”</p>
<h2>4 Example</h2>
<p>As an example I chose the worked “Diabetes” data set that is also included in Python’s <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">sklearn</code> library. It can also be downloaded <a href="https://www4.stat.ncsu.edu/~boos/var.select/diabetes.html">here</a>. For more information, see Efron et al. (2004).</p>
<p>First, we need to load in the data:</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> read in and extract the data</span>
data   <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span>   CSV<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span><span class="syntax--support syntax--function syntax--julia">read</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>data.csv<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span>
target <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> CSV<span class="syntax--keyword syntax--operator syntax--dots syntax--julia">.</span><span class="syntax--support syntax--function syntax--julia">read</span><span class="syntax--meta syntax--bracket syntax--julia">(</span><span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>dtarget.csv<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span></span></pre>
<p>With the data loaded, we can now simply initialize the Elastic Net structure that we created above. Beofre, however, we need to convert the input data to <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">array</code> fromat.</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> read out the array of predictors</span>
X <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">Matrix</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>data<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span>

<span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> read out the array containing the outcome variable</span>
Y <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">Matrix</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>target<span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span>

<span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> initlialize the Lasso/Elastic Net problem with 100 grid points.</span>
model <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">EL_CD</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>Y<span class="syntax--meta syntax--bracket syntax--julia">,</span>X<span class="syntax--meta syntax--bracket syntax--julia">,</span><span class="syntax--constant syntax--numeric syntax--julia">100</span><span class="syntax--meta syntax--bracket syntax--julia">)</span></span></pre>
<p>The <code style="font-family: Menlo, Consolas, &quot;DejaVu Sans Mono&quot;, monospace;">Lasso</code> solution paths can now be computed using</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute the Lasso solution paths</span>
coeffs <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">compute_path</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--meta syntax--bracket syntax--julia">,</span> <span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>Lasso<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span></span></pre>
<p>Our Elastic net class will then automatically set <span class="math inline-math"><script type="math/tex">\alpha=1.0</script></span> and the Elastic Net soft-thresholding rule collapses to Lasso.</p>
<p>Alternatively, Elastic Net solution paths can be computed using</p>
<pre class="editor-colors lang-julia" style="tab-size: 2;"><span class="syntax--source syntax--julia"><span class="syntax--comment syntax--line syntax--number-sign syntax--julia"><span class="syntax--punctuation syntax--definition syntax--comment syntax--julia">#</span> compute Elastic Net solution paths for an example lambda ratio</span>
coeffs2 <span class="syntax--keyword syntax--operator syntax--update syntax--julia">=</span> <span class="syntax--support syntax--function syntax--julia">compute_path</span><span class="syntax--meta syntax--bracket syntax--julia">(</span>model<span class="syntax--meta syntax--bracket syntax--julia">,</span> <span class="syntax--string syntax--quoted syntax--double syntax--julia"><span class="syntax--punctuation syntax--definition syntax--string syntax--begin syntax--julia">"</span>Elastic Net<span class="syntax--punctuation syntax--definition syntax--string syntax--end syntax--julia">"</span></span><span class="syntax--meta syntax--bracket syntax--julia">,</span> <span class="syntax--constant syntax--numeric syntax--julia">0.9</span><span class="syntax--meta syntax--bracket syntax--julia">)</span><span class="syntax--meta syntax--bracket syntax--julia">;</span></span></pre>
<p>In this example code, <span class="math inline-math"><script type="math/tex">\alpha=0.9</script></span>. Generally, our pathwise coordinate descent algorithm runs fairly fast. On my laptop, the solution paths for 100 gird points were computed in less than a second. Of course, this depends on the hardware and the dimensions of the input data.</p>
<p>Finally, we can take a look at the computed solution paths. In the GitHub repository, you can find a version with sliders that allows for interactively changing <span class="math inline-math"><script type="math/tex">\alpha</script></span>, i.e. the relative weight put on the L1 and L2 regularisation during the EL estimation.</p>
<p>As an example, the below plot depicts the solution paths for the Lasso.</p>
<p>@import “C:\Users\A2010183\Desktop\Projects\<a href="http://MaximilianSchroeder.github.io">MaximilianSchroeder.github.io</a>\assets\images\Lasso4.JPG”</p>
<p>In contrast, the solution paths of EL with <span class="math inline-math"><script type="math/tex">\alpha=0.5</script></span> look like this:</p>
<p>@import “C:\Users\A2010183\Desktop\Projects\<a href="http://MaximilianSchroeder.github.io">MaximilianSchroeder.github.io</a>\assets\images\Lasso5.JPG”</p>
<h2>5 Conclusion</h2>
<p>I hope this small tutorial helped shedding some light onto how pathwise coordinate descent can be used to compute the Lasso/EL solutions efficiently and thus allows for deeper understanding of the inner workings of popular Julia, Matlab, and Python libraries.</p>
<h2>6 References</h2>
<p>Donoho, D. L., &amp; Johnstone, I. M. (1995). Adapting to unknown smoothness via wavelet shrinkage. Journal of the american statistical association, 90(432), 1200-1224.</p>
<p>Efron, B., Hastie, T., Johnstone, I., &amp; Tibshirani, R. (2004). Least angle regression. The Annals of statistics, 32(2), 407-499.</p>
<p>Friedman, J., Hastie, T., Höfling, H., &amp; Tibshirani, R. (2007). Pathwise coordinate optimization. The annals of applied statistics, 1(2), 302-332.</p>

  </body>
</html>
